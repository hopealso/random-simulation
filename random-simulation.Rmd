---
title: "Statistical Analysis, MSCA 31007, Lecture 2"
author: "Hope Foster-Reyes"
date: "October 7, 2016"
output: pdf_document
---

# Simulation of Random Variables

_Notes_

* _Style Guide: https://google.github.io/styleguide/Rguide.xml#functiondefinition _

* _Packages required: random, compositions, randtests._

* _Files required: ScratchOffMonteCarlo.rda; store in RStudio project directory_

```{r settings, echo=FALSE}
options(scipen = 5)
```

## Part 1. Generate uniformly distributed random numbers

## 1.1. Use runif().

```{r q1.1}
# Simulate n pseudo-random numbers uniformly distributed on [a,b]
set.seed(15)
sample.runif <- runif(1000, 0, 1)
str(sample.runif)
head(sample.runif)
quantile(sample.runif)
```

## 1.2. Simulate Uniform Random Sample on [0,1] Using Random.org.

```{r q1.2-load1, results='hide'}
# Load random package to interface with random.org
library(random)
```

```{r q1.2}
# Download binary sequence from random.org
num.flips <- 1000
data.random.org <- randomNumbers(n = num.flips, min = 0, max = 1, 
                                 col = 1, base = 2, check = TRUE)
head(data.random.org)
```

**Let us turn our sequence of {0,1} into uniform random numbers on [0,1].**

```{r q1.2-load2, results='hide'}
# Load compositions package
suppressMessages(library(compositions))
```

```{r q1.2-transform}
# Create function that interprets a sequence of zeros and ones of length n as a binary
#   number and converts that binary into decimal
BinaryToDec <- function(binary.seq){
  # Argument binary.seq: vector containing a binary sequence of 0's and 1's
  unbinary(paste(binary.seq, collapse = ""))
}

# Demonstrate function
BinaryToDec(c(1,1,1,1,1,0))

# Turn the sequence of 0's and 1's from random.org into a 100x10 matrix
matrix.binary <- matrix(data.random.org, ncol = 10)
head(matrix.binary)
str(matrix.binary)

# Transform each row into decimal format
vector.decimal <- apply(matrix.binary, 1, BinaryToDec)
str(vector.decimal)

# Divide the numbers by 2^10 to make real numbers in [0,1]
sample.random.org <- vector.decimal / 2^10
str(sample.random.org)
sample.random.org
quantile(sample.random.org)
```

All numbers in sample.random.org are between 0 and 1. This is our equivalent of the sample obtained by runif().

## Part 2. Test random number generator

## 2.1. Test uniformity of distribution of both random number generators

### 2.1.1. Sample obtained by runif()

Analyze what was simulated.

```{r q2-1-1-hist}
title.runif <- "1000 Pseudo-Random Numbers via Runif()"
hist.runif <- hist(sample.runif, main = title.runif)
hist.runif
boxplot(sample.runif, main = title.runif)
```

***What does the histogram tell you about the distribution? Is it consistent with the goal of simulation?***

??? XXX ???

Estimate mean and standard deviation of our sample's density.

```{r q2-1-1-spread}
(hist.runif.mean <- mean(hist.runif$density))
(hist.runif.sd <- sd(hist.runif$density))

plot(hist.runif, freq = FALSE, main = paste("Spread of", title.runif))
abline(h = hist.runif.mean)
abline(h = hist.runif.mean + 1.96 * hist.runif.sd, col = "red", lty = 2)
abline(h = hist.runif.mean - 1.96 * hist.runif.sd, col = "red", lty = 2)
```

***What does the graph tell you about the observed distribution?***

??? XXX ???

Estimate the moments of the sample.

```{r q2-1-1-moments}
(sample.runif.mean <- mean(sample.runif))
(sample.runif.var <- var(sample.runif))
```

***What do you conclude about the estimated distribution from the moments?***

??? XXX ???

Check the summary of the simulated sample.

```{r q2-1-1-iqr}
summary(sample.runif)
```

***What do you think is the best way of estimating uniform distribution over unknown interval?***

??? XXX ???

### 2.1.2. Repeat the same steps to test uniformity of the sample created from Random.org data.

Analyze what was simulated.

```{r q2-1-2-hist}
title.random.org <- "100 Pseudo-Random Numbers, Transformed from Random.org Binary Data"
hist.random.org <- hist(sample.random.org, main = title.random.org)
hist.random.org
boxplot(sample.random.org, main = title.random.org)
```

***What does the histogram tell you about the distribution? Is it consistent with the goal of simulation?***

In other words, we know that our goal is a unified distribution on [0,1]. In a unified distribution on [0,1], as the size of the sample increases, the frequency of the outcomes should approach being equal, and their density should approach 1. 

Since the densities of our sample should approach 1 and be equal, their mean of course should also approach 1 and should not deviate excessively.

??? XXX ???

Estimate mean and standard deviation of our sample's density.

```{r q2-1-2-spread}
(hist.random.org.mean <- mean(hist.random.org$density))
(hist.random.org.sd <- sd(hist.random.org$density))

plot(hist.random.org, freq = FALSE, main = paste("Spread of", title.random.org))
abline(h = hist.random.org.mean)
abline(h = hist.random.org.mean + 1.96 * hist.random.org.sd, col = "red", lty = 2)
abline(h = hist.random.org.mean - 1.96 * hist.random.org.sd, col = "red", lty = 2)
```

***What does the graph tell you about the observed distribution?***

??? XXX ???

Estimate the moments of the sample.

```{r q2-1-2-moments}
(sample.random.org.mean <- mean(sample.random.org))
(sample.random.org.var <- var(sample.random.org))
```

***What do you conclude about the estimated distribution from the moments?***

??? XXX ???

Check the summary of the simulated sample.

```{r q2-1-2-iqr}
summary(sample.random.org)
```

??? XXX ???

## 2.2. Test independence of the sequence of zeros and ones

### 2.2.1. Turning point test

Check if a sequence of numbers is i.i.d. (independent identically distributed) based on the number of turning points in the sequence.

The number of turning points is the number of maxima and minima in the series. The statistic of the test has a standard normal distribution and is performed by turning.point.test() in package randtests.

```{r q2-2-1-load, results='hide'}
library(randtests)
```

```{r q2-2-1}
turning.point.test(sample.random.org)
```

The null hypothesis tested by turning point test is randomness (i.i.d.). The alternative is serial correlation in the sequence. Thus, if the test returns a very small p-value the randomness needs to be rejected.

## 2.3. Test frequency by Monobit test

To perform Monobit test you need to transform your {0,1} sample into {-1,1}.

```{r q2-3-transform}
data.random.org.plusminus1 <- (data.random.org - .5) * 2
```

The monobit test can be calculated in R with the help of pnorm. The test checks that the the p-value or complimentary error function of a statistic S is less than or equal to 0.01. If not, the sequence fails the test.

```{r q2-3}
erf.monobit <- function(x) 2 * pnorm(x * sqrt(2)) - 1
erfc.monobit <- function(x) 2 * pnorm(x * sqrt(2), lower = FALSE)

# Chart the complimentary error function
plot(seq(from = -3, to = 3, by = 0.5), erfc.monobit(seq(from = -3, to = 3, by = 0.5)),
     type = "l", xlab = "x", ylab = "erfc.monobit(x)")

# Calculate our S statistic
s.monobit.random.org <- abs(sum(data.random.org.plusminus1) / sqrt( 2* num.flips))

# Find the p-value or erfc(S)
erfc.monobit(s.monobit.random.org)
```

The test shows that our sequence passes.

Now check each of the sub-sequences created earlier:

```{r q2-3-subsseq}
# Create matrix of sub-sequences
matrix.plusminus1 <- matrix(data.random.org.plusminus1, ncol=50)

# Find p-value of vector of S statistics for every sub-sequence
erfc.random.org.subseq <- erfc.monobit(abs(apply(matrix.plusminus1, 1, sum)) / sqrt(2 * 50))

# Plot
plot(erfc.random.org.subseq, ylab = "P-Values", 
     main = "Monobit Complimentary Error Function on 20 Sequences of Random.org Data")
```

***How many runs out of 20 fail the test?***

```{r q2-3-subseq-test}
sum(erfc.random.org.subseq <= 0.01)
```

We can confirm that the random sequences provided by Random.org pass the monobit test.

## Part 3. Invent a random number generator

??? XXX ???

## Part 4. Monte Carlo Method

## 4.1. Scratch off quote of the day: fuction download

```{r q4-1-load, results='hide'}
filename <- ScratchOffMonteCarlo.rda

#path <- "{Path to the folder with ScratchOffMonteCarlo.rda}"
#load(file = paste(path, filename,sep= '/ '))

# Place ScratchOffMonteCarlo file in project directory or use code above
load(filename)
```

## 4.2. Simulate pseudo-random poins [x,y][x,y] on [0,100]×[0,100]

The ScratchOffMonteCarlo function simulates 'scratching off the paint' covering an image at each x, y coordinate. Let's try creating 1000 pseudo-random x, y coordinates and see if the image is readable.

```{r q4-1-example}
# Set seed
seed1 <- 938364
set.seed(seed1)

# Set sample size
mc.n <- 1000

# Simulate n * 2 pseudo-random numbers uniformly distributed on [0, 100]
mc.xy <- runif(2 * mc.n, min = 0, max = 100)

# Transform into n x 2 matrix
mc.xy <- matrix(mc.xy, ncol = 2)
str(mc.xy)
head(mc.xy)

# Simulate 'scratching off the paint' covering an image at each x, y coordinate
ScratchOffMonteCarlo(mc.xy)
```

Let's adjust the sample size and seed and try to make the quote in our image readable with minimum sample size.

```{r q4-1-trials}
# Create function to generate coordinate matrix
xy <- function(n, seed) {
  # Argument n: Number of x, y coordinate samples to generate
  # Argument seed: Seed to ensure reproducibility
  
  # Simulate n * 2 pseudo-random numbers uniformly distributed on [0, 100]
  set.seed(seed)
  xy <- runif(2 * n, min = 0, max = 100)

  # Transform into n x 2 matrix
  xy <- matrix(xy, ncol = 2)
}

# Seed 1 5k:
mc2.n <- 5000
mc2.xy <- xy(mc2.n, seed1)
ScratchOffMonteCarlo(mc2.xy)

# Seed 2 5k:
seed2 <- 112233
mc2.n <- 5000
mc2.xy <- xy(mc2.n, seed2)
ScratchOffMonteCarlo(mc2.xy)

# Seed 1 10k:
mc2.n <- 10000
mc2.xy <- xy(mc2.n, seed1)
ScratchOffMonteCarlo(mc2.xy)

# Seed 2 10k:
mc2.n <- 10000
mc2.xy <- xy(mc2.n, seed2)
ScratchOffMonteCarlo(mc2.xy)

# Seed 1 15k:
mc2.n <- 15000
mc2.xy <- xy(mc2.n, seed1)
ScratchOffMonteCarlo(mc2.xy)

# Seed 2 15k:
mc2.n <- 15000
mc2.xy <- xy(mc2.n, seed2)
ScratchOffMonteCarlo(mc2.xy)

# Seed 3 15k:
seed3 <- 999999
mc2.n <- 15000
mc2.xy <- xy(mc2.n, seed3)
ScratchOffMonteCarlo(mc2.xy)

# Seed 2 19k:
mc2.n <- 19000
mc2.xy <- xy(mc2.n, seed2)
ScratchOffMonteCarlo(mc2.xy)

# Seed 2 23k:
mc2.n <- 23000
mc2.xy <- xy(mc2.n, seed2)
ScratchOffMonteCarlo(mc2.xy)

# Seed 2 25k:
mc2.n <- 25000
mc2.xy <- xy(mc2.n, seed2)
ScratchOffMonteCarlo(mc2.xy)

# Seed 1 25k:
mc2.n <- 25000
mc2.xy <- xy(mc2.n, seed1)
ScratchOffMonteCarlo(mc2.xy)

# Seed 3 25k:
mc2.n <- 25000
mc2.xy <- xy(mc2.n, seed3)
ScratchOffMonteCarlo(mc2.xy)
```

***What percent you needed to scratch off to make the quote readable?***

It appears we need to scratch off approximately 90% of the paint to make the quote and its author readable. (We can read the English words at less due to the cognitive ability to fill in letters in words that match existing patterns, but unknown names require more letters to be readable.)

## 4.3. Simulate quasi-random poins [x,y][x,y] on [0,100]×[0,100]

Again, by changing nSample and my.seed we try to make the quote of the day readable with minimum sample size.

***What percent you needed to scratch off to make the quote readable?***

***Which of the Monte Carlo methods makes the quote readable sooner?***

***Which parameters nSample and my.seed gave you the best result, what percent of the yellow paing you were able to scratch off by each method?***

***Changing which of the two parameters plays more significant role?***

## Workshop: Simulation of random variables using distribution function and inverse distribution function

```{r inv-function-norm}
xNorm<-qnorm((1:99)/100)
yNorm<-pnorm(xNorm)
plot(xNorm,yNorm,pch=16)
abline(h=yNorm)
abline(v=xNorm)
abline(h=yNorm[30],col="green",lwd=3)
abline(v=xNorm[30],col="green",lwd=3)
lines(xNorm,dnorm(xNorm),lwd=3,col="red")
```

## Part 5. Test

```{r q5}
# Load data. (Data file must be located in RStudio project directory.)
data <- read.csv('Week2_Test_Sample.csv', header = TRUE)$x

# Using sample from uniform distribution, create sample from normal distribution. 
data.norm <- qnorm(data[4:503], mean = data[1], sd = data[2])
hist(data.norm)

# Using sample from uniform distribution, create sample from exponential distribution.
data.exp <- qexp(data[4:503], rate = data[3])
hist(data.exp)

# Output results to RStudio project directory
result <- cbind(datNorm = data.norm, datExp = data.exp)
write.csv(result, 'result.csv', row.names = FALSE)
```

